<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Multiple choropleth maps</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <script type="text/javascript" src="js/mapbox.js?v=2.2.2"></script>
    <script type="text/javascript" src="js/jquery.js"></script>
    <script type="text/javascript" src="data/countrynames.js"></script>


    <link rel="stylesheet" type="text/css" href="css/reset.css">
    <link rel="stylesheet" type="text/css" href="css/style.css">

    <link href="css/leaflet.css" rel="stylesheet" />
</head>
<body>



<div id="map"></div>

<div id="variablesButton">
    <a id="hamburger" onclick="metroMode ()"></a>
    <div class="content"></div>
</div>


<div id="header">
    <div class="content"></div>
</div>

<div id="legenda">
    <div class="bestcountry"></div>
    <div class="hovercontent"></div>
</div>

<script type="text/javascript">

L.mapbox.accessToken = 'pk.eyJ1IjoibWFwYm94IiwiYSI6IjZjNmRjNzk3ZmE2MTcwOTEwMGY0MzU3YjUzOWFmNWZhIn0.Y8bhBaUMqFiPrDRW9hieoQ';
var map = L.mapbox.map(
        'map', 'mapbox.light', {zoomControl: false})
    .setView([53, 20], 3);

// Be nice and credit our data source, Census Reporter.
// map.attributionControl.addAttribution('Data from ' +
//   '<a href="http://censusreporter.org/data/map/?table=B06011&geo_ids=040%7C01000US#">' +
//   'Census Reporter</a>');












// Choropleth colors from http://colorbrewer2.org/
// You can choose your own range (or different number of colors)
// and the code will compensate.

// // negatief
// var hues = [
//     '#FF0C00',
//     '#501C19',
//     '#502C2A',
//     '#FFCFCD',
//     '#9DE1B7',       
//     '#63E193',
//     '#30E174',
//     '#00B244'];  

var hues = [
    '#00B244',
    '#30E174',
    '#63E193',
    '#9DE1B7', // groen
    '#FFCFCD', // rood
    '#502C2A',
    '#501C19',
    '#FF0C00',

    '#5189B2', // Blue
    '#CCCCCC' // NaN
    ];


var goodHues = [
    '#00B244',
    '#30E174',
    '#63E193',
    '#9DE1B7']

var badHues = [
    '#FFCFCD', // rood
    '#502C2A',
    '#501C19',
    '#FF0C00']


var NaNescaper  = -9;


// The names of variables that we'll show in the UI for
// styling. These need to match exactly.
var variables = [
    'gini',
    'freedom',
    'gemiddeld-ink',
    'jobs-avail',
    'werkloosheid',
    'discrimi'
    ];
// name,nl_name,en_name,gini,absoluut-gino,freedom,absoluut-inwoner-aantal,gemiddeld-ink,jobs-avail,werkloosheid


var variablesUI = [
    'Gelijkheid in inkomen',
    'Vrijheid en inspraak',
    'Een hoog inkomen',
    'Veel werkgelegenheid',
    'Lage werkloosheid',
    'Weinig discriminatie'
    ];


var variablesIsHighToLow = {
    "gini": false,
    'freedom': false,
    'gemiddeld-ink': true,
    'jobs-avail': true,
    'werkloosheid': false,
    'discrimi': true
    };


var variablesScale = {
    "gini": "x zo veel verdienen",
    'freedom': "Persvrijheid score",
    'gemiddeld-ink': "gemideld inkomen in euro",
    'jobs-avail': "banen beschikbaar",
    'werkloosheid': "% werkloos",
    'discrimi': "discriminatie score"
    };

for (var i = 0; i < variables.length; i++) {
    document.querySelector("#variablesButton .content").innerHTML += "<li class='" + variables[i]+ "'> <img src='images/"  + variables[i] + ".svg' /> <a onclick='setVariable(\"" + variables[i]  + "\")'>" + variablesUI[i] +"</a> </li>";
}


// var variables = [
//     'B06011002 - Born in state of residence',
//     'B06011003 - Born in other state of the United States',
//     'B06011004 - Native; born outside the United States'];




// Collect the range of each variable over the full set, so
// we know what to color the brightest or darkest.
var ranges = {};
var $select = $('<select></select>')
    .appendTo($('#variables'))
    .on('change', function() {
        setVariable($(this).val());
    });
for (var i = 0; i < variables.length; i++) {
    ranges[variables[i]] = { min: Infinity, max: -Infinity };
    // Simultaneously, build the UI for selecting different
    // ranges
    $('<option></option>')
        .text(variables[i])
        .attr('value', variables[i])
        .appendTo($select);
}

// Create a layer of state features, and when it's done
// loading, run loadData
var euLayer = L.mapbox.featureLayer()
    .loadURL('data/europe.geo.json')
    .addTo(map)
    .on('ready', loadData);


// var euLayer = L.mapbox.featureLayer()
//     .loadURL('data/europe.geo.json')
//     .addTo(map)
//     .on('ready', loadData);

  // var statesLayer = L.geoJson(statesData,  {
  //     style: getStyle,
  //     onEachFeature: onEachFeature
  // }).addTo(mapdataviz);


    // .loadURL('https://www.mapbox.com/mapbox.js/assets/data/us.geojson')


// Grab the spreadsheet of data as JSON. If you have CSV
// data, you should convert it to JSON with
// http://shancarter.github.io/mr-data-converter/
function loadData() {
    $.getJSON('data/data.json')
        .done(function(data) {
            joinData(data, euLayer);
        });
}
//     $.getJSON('https://www.mapbox.com/mapbox.js/assets/data/censusdata.json')


function joinData(data, layer) {
    // First, get the US state GeoJSON data for reference.

    var euGeoJSON = euLayer.getGeoJSON(),
        byState = {};

    // Rearrange it so that instead of being a big array,
    // it's an object that is indexed by the state name,
    // that we'll use to join on.
    for (var i = 0; i < euGeoJSON.features.length; i++) {
        
        // console.log(byState);

        byState[euGeoJSON.features[i].properties.name] =
            euGeoJSON.features[i];
    }


    for (i = 0; i < data.length; i++) {

     // Match the GeoJSON data (byState) with the tabular data
        // (data), replacing the GeoJSON feature properties
        // with the full data.
        try {
            byState[data[i].name].properties = data[i];
        }
        catch(e){}

        for (var j = 0; j < variables.length; j++) {
            // Simultaneously build the table of min and max
            // values for each attribute.

            var n = variables[j];
            // console.log("range")
            // console.log(ranges[n]);
            // console.log(data[i][n]);

            ranges[n].min = Math.min(data[i][n], ranges[n].min);
            ranges[n].max = Math.max(data[i][n], ranges[n].max);

            // Min / Max Name
            if (data[i][n] != NaNescaper) {
                if (data[i][n] === ranges[n].min) {
                    ranges[n].minname = data[i].name;
               };
            };
            if (data[i][n] === ranges[n].max) {
                ranges[n].maxname = data[i].name;
            };


        }

        if (variablesIsHighToLow[name]) {
            // max is best
            bestCountry (variables[0])

        }
        else {
            // min is best
            bestCountry (variables[variables.length-1])

        }


    }


    // Create a new GeoJSON array of features and set it
    // as the new usLayer content.
    var newFeatures = [];
    for (i in byState) {
        newFeatures.push(byState[i]);
    }
    euLayer.setGeoJSON(newFeatures);




 

    // Kick off by filtering on an attribute.
    setVariable(variables[0]);
}







// Excuse the short function name: this is not setting a JavaScript
// variable, but rather the variable by which the map is colored.
// The input is a string 'name', which specifies which column
// of the imported JSON file is used to color the map.
function setVariable(name) {
    var scale = ranges[name];
    euLayer.eachLayer(function(layer) {
        // Decide the color for each state by finding its
        // place between min & max, and choosing a particular
        // color as index.
        var division = Math.floor(
            (hues.length - 3) *
            ((layer.feature.properties[name] - scale.min) /
            (scale.max - scale.min)));


        // console.log(name)




        if (variablesIsHighToLow[name]) {
            // console.log("max is best")

           // negative
            var divisionNeg = division * -1;
            division = (hues.length - 3) + divisionNeg;


            // max is best
            if (layer.feature.properties[name] === scale.max) {
                var division = hues.length - 2;
            };


        }
        else {
            // min is best
            // console.log("min is best")


            if (layer.feature.properties[name] === scale.min) {
                    var division = hues.length - 2;
            };            

        }






        if (layer.feature.properties[name] === NaNescaper) {
            var division = hues.length - 1;
        };


        // See full path options at
        // http://leafletjs.com/reference.html#path
        layer.setStyle({
            fillColor: hues[division],
            fillOpacity: 0.8,
            color: '#666',
            weight: 0.5
        });

        layer.addEventListener("mouseover", function(e){ var those = this; hoverLegenda(e,those,name) }, false);
        layer.addEventListener("mouseout", function(e){ var those = this; resetHighlight(e,those) }, false);

        layer.addEventListener("click", function(e){ var those = this; filterCountry(e,those,name) }, false);

    });

    bestCountry (name)
    setColorOfVariablesButton (name)
    metroMode ()
    displayCurrentType (name)
}


function bestCountry (name) {
        // console.log("ranges!")
        // console.log(     ranges[name].maxname )
        // console.log(     ranges[name].max )


    // console.log(countrynames)

    if (variablesIsHighToLow[name]) {
        // max is best
        document.querySelector("#legenda .bestcountry").innerHTML = "Goedste land == " + "<img src='images/" + ranges[name].maxname + ".jpg'/> " + countrynames[ranges[name].maxname] + " " + ranges[name].max;
    }
    else {
        // min is best
        document.querySelector("#legenda .bestcountry").innerHTML = "Goedste land == " + "<img src='images/" + ranges[name].minname + ".jpg'/> " + countrynames[ranges[name].minname] + " " + ranges[name].min;

    }



}





var isMetroOn = true;

function metroMode () {
    if (isMetroOn == true) {
        $( "#variablesButton").css("width", "50px" );
        $( "#variablesButton").css("height", "50px" );
        $( "#variablesButton .content").css("display", "none" );

        isMetroOn = false;
    }
    else {
        $( "#variablesButton").css("width", "100vw" );
        $( "#variablesButton").css("height", "100vh" );        
        $( "#variablesButton .content").css("display", "block" );

        isMetroOn = true;

    }


}

function displayCurrentType (name) {

    var name_pos = variables.indexOf(name); 
    document.querySelector("#header .content").innerHTML = variablesUI[name_pos];

}



function setColorOfVariablesButton (name) {




    $( "#variablesButton .content" ).each(function() {
        $( this ).css( "backgroundColor", "white" );
    });


    $('#variablesButton .content').children('li').each(function () {
        $( this ).css( "backgroundColor", "white" );
        // alert(this.value); // "this" is the current element in the loop
    });

    $( "#variablesButton .content " + " ." + name).css("backgroundColor", "red" );


}

function resetHighlight(e,those) {
    // console.log("reset")
    // console.log(e.target)

        var layer = e.target;

            layer.setStyle({
                weight: 0.5,
                color: '#666',
                dashArray: '',
                fillOpacity: 0.7
            });


    // euLayer.resetStyle(e.target);
}


function hoverLegenda (e,those,name) {
    // console.dir(e)
    // console.log(e.target.feature.properties[name])

    // e.fill = "#555555";
    // e.layer.options.fillColor = "#515555"

        var layer = e.target;

            layer.setStyle({
                weight: 5,
                color: '#FF6000',
                dashArray: '',
                fillOpacity: 0.7
            });


    // 'gino',
    // 'freedom',
    // 'werkloos-man',
    // 'werkloos-vrouw',
    // 'vluchteling-10k-inwoner',
    // 'uurloon-gemiddelde'


    // // this country
    // var value = e.target.feature.properties[name];
    // value = Math.round(value);

    // if (e.target.feature.properties[name] == NaNescaper) {
    //     value = "geen data"
    // };

    // document.querySelector("#legenda .hovercontent").innerHTML = e.target.feature.properties["nl_name"] + " " + value ;

    document.querySelector("#legenda .hovercontent").innerHTML = countrynames[e.target.feature.properties["name"]] + "<br />";

    for (var i = 0; i < variables.length; i++) {
        // console.log(variables[i]);

        var value = e.target.feature.properties[variables[i]];
        value = Math.floor(value);
        document.querySelector("#legenda .hovercontent").innerHTML += value + variablesScale[variables[i]] + "<br />";

    };




}



function filterCountry(e,those,name) {
    // name = gini

    // console.log(e.target.feature.properties[name]);
   
    var thisCountryScore = e.target.feature.properties[name];

    var scoreList = [];
    euLayer.eachLayer(function(layer) {
        scoreList.push(layer.feature.properties[name]);
    });


    var scale = ranges[name];

    function map(value, low1, high1, low2, high2) {
        return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
    }

    // console.log("~~~~~~~~~~~~~~~~~~~~~~ "  + badHues.length + " " +  goodHues.length)
    euLayer.eachLayer(function(layer) {

        if (layer.feature.properties[name] < thisCountryScore) {
            // landen die het beter doen

            // console.log("beter " + layer.feature.properties[name] )

            
            if (variablesIsHighToLow[name]) {
                // console.log("High")
                var outMin = badHues.length;
                var outMax = 0;

                var division = Math.floor(
                    map( layer.feature.properties[name],  scale.max+1,  scale.min-1,  outMax, outMin  )
                    );

                var color = badHues[division]

           }
            else {
                // console.log("low")
                var outMin = 0;
                var outMax = goodHues.length;

                var division = Math.floor(
                    map( layer.feature.properties[name],  scale.max+1,  scale.min-1,  outMax, outMin  )
                    );

                var color = goodHues[division]
            }




                // map( layer.feature.properties[name],  21,  4,  4, 0  )


        }
        else if  (layer.feature.properties[name] === thisCountryScore) {
            var color = "#8AB2A7";

            if (layer.feature.properties["name"] === e.target.feature.properties["name"]) {
                 var color = "#5189B2";
            };
        }
        else {

            
            if (variablesIsHighToLow[name]) {
                // console.log("High")

                var outMin = goodHues.length;
                var outMax = 0

                var division = Math.floor(
                    map( layer.feature.properties[name],  scale.max+1,  scale.min-1,  outMax, outMin  )
                    );

                var color = goodHues[division]
            }
            else {
                var outMin = goodHues.length;
                var outMax = 0;

                var division = Math.floor(
                    map( layer.feature.properties[name],  scale.min-1,  scale.max+1,  outMin, outMax  )
                    );

                var color = badHues[division]

            }
                


        }



        // var division = Math.floor(
        //     (hues.length - 3) *
        //     ((layer.feature.properties[name] - scale.min) /
        //     (scale.max - scale.min)));



        layer.setStyle({
            fillColor: color,
            fillOpacity: 0.8,
            color: '#666',
            weight: 0.5
        });
    });
}



// function median(values) {
//     // / /https://gist.github.com/caseyjustus/1166258
//     values.sort( function(a,b) {return a - b;} );

//     var half = Math.floor(values.length/2);

//     if(values.length % 2)
//         return values[half];
//     else
//         return (values[half-1] + values[half]) / 2.0;
// }

</script>


</body>
</html>

