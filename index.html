<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Multiple choropleth maps</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <script type="text/javascript" src="js/mapbox.js?v=2.2.2"></script>
    <script type="text/javascript" src="js/jquery.js"></script>
    <script type="text/javascript" src="data/countrynames.js"></script>

    <link type="text/plain" rel="author" href="../humans.txt" /> 

    <link rel="stylesheet" type="text/css" href="css/reset.css">
    <link rel="stylesheet" type="text/css" href="css/style.css">

    <link href="css/leaflet.css" rel="stylesheet" />
</head>
<body>

<!--

    STOP READING CODE, HIRE ME!
    check humans.txt for contact information


                          ,                                  
                         ,:                                  
          ,:==++=~,      :~                                  
        ,=+=:::::+?~     ~=                 ,,                  
       ~+~:~==++=,,~,    ~=                :==:   ,=~,       ,   
      ==,~      :~,      ~~       ~??~     :~ =:   :I=      ,,        
     ~~=,        ==,    ,~II    :?$+=?=:      ?,   ++:     ;;  
    ,==~~      ,,,   ,?Z$7ZI:  ,I$,  ~?:   +$$=,  ,+?,+= ,:;  
     =+:     ,,,:  ,7Z: ,~=,   =I?~,+7   ,=$~,=I~   +I~77 ~:,  
    ,=~:,   :==~::  ?I~  ,~=,  ,?$Z7$?:  +7:  ~I~   +$I==I=:   
    ,=~:~:,:~=++,  ,I?:  ,=?:  :I7+~~:  ,?7:,~++,   =$I :I+,   
     ,==::::::+?=~  ~II,,=II,  ,??: :~~  +?=++I$+   ~7? ,++:   
       :~::~:, :+?+:  ?II+~:  ,:+~   ,~~  ==~::::,  :+,  :=:   
                ,=II+:        ,:,    ,~=:                    
                  :=~==                ~=,                   
                      ,                ,::                            
        
-->


<div id="map"></div>

<div id="variablesButton">
    <h1 class="head"> Kies wat je het belangrijkste thema vind</h1>
    <div class="content"></div>
</div>

<div id="sidebar">
    <div id="header"></div>
    <div id="content">
    </div>

    <div id="legenda">
    </div>
</div>


<script type="text/javascript">

L.mapbox.accessToken = 'pk.eyJ1IjoibWFwYm94IiwiYSI6IjZjNmRjNzk3ZmE2MTcwOTEwMGY0MzU3YjUzOWFmNWZhIn0.Y8bhBaUMqFiPrDRW9hieoQ';
// Replace 'mapbox.streets' with your map id.
var mapboxTiles = L.tileLayer('https://api.mapbox.com/v4/mapbox.light/{z}/{x}/{y}.png?access_token=' + L.mapbox.accessToken, {
    attribution: '<a href="sources.html" target="_blank">Bronvermelding</a>'
});


var map = L.map('map',{ zoomControl:false })
    .addLayer(mapboxTiles)
    .setView([55, 13], 4);

var popup = new L.Popup({ autoPan: false });

// Be nice and credit our data source, Census Reporter.
// map.attributionControl.addAttribution('Data from ' +
//   '<a href="http://censusreporter.org/data/map/?table=B06011&geo_ids=040%7C01000US#">' +
//   'Census Reporter</a>');

// By the way, thanks: https://www.mapbox.com/mapbox.js/example/v1.0.0/choropleth-joined-data-multiple-variables/ for letting me copy paste this example



// Choropleth colors from http://colorbrewer2.org/
// You can choose your own range (or different number of colors)
// and the code will compensate.
// Didn't use anyway ;)


var hues = [
    '#00B244', // green
    '#30E174',
    '#63E193',
    '#9DE1B7', // light green
    '#FFCFCD', // light red
    '#502C2A',
    '#501C19',
    '#FF0C00', // more red

    '#5189B2', // Blue
    '#CCCCCC' // NaN
    ];


// Positive Hues for filter feature
var goodHues = [
    '#00B244',
    '#30E174',
    '#63E193',
    '#9DE1B7']

// Negative Hues for filter feature
var badHues = [
    '#FFCFCD', // rood
    '#502C2A',
    '#501C19',
    '#FF0C00']



// NaN escaper feature in data set, if you use NaN the app will crash
var NaNescaper  = -9;


// The names of variables that we'll show in the UI for
// styling. These need to match exactly.

// Those names are used in the ./data/data.json

var variables = [
    'gini',
    'freedom',
    'gemiddeld-ink',
    'jobs-avail',
    'werkloosheid',
    'discrimi',
    'corruption'
    ];

// UI-names for variables, use the same order
var variablesUI = [
    'Gelijkheid in inkomen',
    'Vrijheid en inspraak',
    'Een hoog inkomen',
    'Veel werkgelegenheid',
    'Lage werkloosheid',
    'Weinig discriminatie',
    "Niet nodig om om te kopen"
    ];

// Using High to low or reverse
var variablesIsHighToLow = {
    "gini": false,
    'freedom': false,
    'gemiddeld-ink': true,
    'jobs-avail': true,
    'werkloosheid': false,
    'discrimi': true,
    'corruption': true
    };

// The scale of the variable
var variablesScale = {
    "gini": "x zo veel verdienen",
    'freedom': "Persvrijheid score",
    'gemiddeld-ink': "gemideld inkomen in euro",
    'jobs-avail': "banen beschikbaar",
    'werkloosheid': "% werkloos",
    'discrimi': "discriminatie score",
    'corruption': "hoe eerlijk het is"
    };

var variablesExplain = {
    "gini": "De Gini-coëfficiënt wordt meestal gebruikt om de inkomensongelijkheid te meten, maar is geschikt om elke vorm van ongelijkmatige verspreiding te meten. De Gini-coëfficiënt is een getal tussen 0 en 1. De waarde 0 correspondeert hierbij met ‘perfecte gelijkheid’ ",
    'freedom': "Persvrijheid score",
    'gemiddeld-ink': "gemideld inkomen in euro",
    'jobs-avail': "banen beschikbaar",
    'werkloosheid': "% werkloos",
    'discrimi': "discriminatie score",
    'corruption': "hoe eerlijk het is"
    };






// Display all options in 1 div
for (var i = 0; i < variables.length; i++) {
    document.querySelector("#variablesButton .content").innerHTML += "<li onclick='setVariable(\"" + variables[i]  + "\")' class='" + variables[i]+ "'> <img src='images/"  + variables[i] + ".svg' /><span>" + variablesUI[i] +"</span> </li>";
}



// Collect the range of each variable over the full set, so
// we know what to color the brightest or darkest.
var ranges = {};

var $select = $('<select></select>')
    .appendTo($('#variables'))
    .on('change', function() {
        setVariable($(this).val());
    });
for (var i = 0; i < variables.length; i++) {
    ranges[variables[i]] = { min: Infinity, max: -Infinity };
    // Simultaneously, build the UI for selecting different
    // ranges
    $('<option></option>')
        .text(variables[i])
        .attr('value', variables[i])
        .appendTo($select);
}

// Create a layer of state features, and when it's done
// loading, run loadData
var euLayer = L.mapbox.featureLayer()
    .loadURL('data/europe.geo.json')
    .addTo(map)
    .on('ready', loadData);

// Grab the spreadsheet of data as JSON. If you have CSV
// data, you should convert it to JSON with
// http://shancarter.github.io/mr-data-converter/
function loadData() {
    $.getJSON('data/data.json')
        .done(function(data) {
            joinData(data, euLayer);
        });
}

function joinData(data, layer) {
    // First, get the Europian state GeoJSON data for reference.

    var euGeoJSON = euLayer.getGeoJSON(),
        byState = {};

    // Rearrange it so that instead of being a big array,
    // it's an object that is indexed by the state name,
    // that we'll use to join on.
    for (var i = 0; i < euGeoJSON.features.length; i++) {
        
        byState[euGeoJSON.features[i].properties.name] =
            euGeoJSON.features[i];
    }


    for (i = 0; i < data.length; i++) {

     // Match the GeoJSON data (byState) with the tabular data
        // (data), replacing the GeoJSON feature properties
        // with the full data.
        try {
            byState[data[i].name].properties = data[i];
        }
        catch(e){}

        for (var j = 0; j < variables.length; j++) {
            // Simultaneously build the table of min and max
            // values for each attribute.

            var n = variables[j];

            // The minimum
            ranges[n].min = Math.min(data[i][n], ranges[n].min);
            ranges[n].max = Math.max(data[i][n], ranges[n].max);


            // Min / Max Name for example 'NL'
            if (data[i][n] != NaNescaper) {
                if (data[i][n] === ranges[n].min) {
                    ranges[n].minname = data[i].name;
               };
            };
            if (data[i][n] === ranges[n].max) {
                ranges[n].maxname = data[i].name;
            };


        }

        // using in reverse or first gear?
        if (variablesIsHighToLow[name]) {
            // max is best
            bestCountry (variables[0])

        }
        else {
            // min is best
            bestCountry (variables[variables.length-1])

        }


    }


    // Create a new GeoJSON array of features and set it
    // as the new usLayer content.
    var newFeatures = [];
    for (i in byState) {
        newFeatures.push(byState[i]);
    }
    euLayer.setGeoJSON(newFeatures);




 

    // Kick off by filtering on an attribute.
    setVariable(variables[0]);
}




function legenda (name) {


    if (variablesIsHighToLow[name]) {
        document.querySelector("#sidebar #legenda").innerHTML = "   <h2> Legenda </h2>   <span style='float:left'>Lager</span>        <span style='float:left; text-align:right'>Hoger</span>";
    }
    else {
        document.querySelector("#sidebar #legenda").innerHTML = "   <h2> Legenda </h2>   <span style='float:left'>Hoger</span>        <span style='float:left; text-align:right'>Lager</span>";
    }



    for (var i = 0; i < hues.length-2; i++) {
        console.log(hues[i])
        $( "#sidebar #legenda" ).append( "  <div style='background-color:" + hues[i] +"'></div>" );
    };
}


// Excuse the short function name: this is not setting a JavaScript
// variable, but rather the variable by which the map is colored.
// The input is a string 'name', which specifies which column
// of the imported JSON file is used to color the map.
function setVariable(name) {
    var scale = ranges[name];
    euLayer.eachLayer(function(layer) {
        // Decide the color for each state by finding its
        // place between min & max, and choosing a particular
        // color as index.
        // This is like the arduino map feature
        var division = Math.floor(
            (hues.length - 3) *
            ((layer.feature.properties[name] - scale.min) /
            (scale.max - scale.min)));


        if (variablesIsHighToLow[name]) {

            // higher is beter

            var divisionNeg = division * -1;
            division = (hues.length - 3) + divisionNeg;

            if (layer.feature.properties[name] === scale.max) {
                var division = hues.length - 2;
            };
        }
        else {
            // lower is beter

            if (layer.feature.properties[name] === scale.min) {
                    var division = hues.length - 2;
            };            

        }

        // Give the NaN a grey colour
        if (layer.feature.properties[name] === NaNescaper) {
            var division = hues.length - 1;
        };


        // See full path options at
        // http://leafletjs.com/reference.html#path
        layer.setStyle({
            fillColor: hues[division],
            fillOpacity: 0.8,
            color: '#666',
            weight: 0.5
        });

        // YEAH, eventListeners
        layer.addEventListener("mouseover", function(e){ var those = this; mousemove(e,those,name) }, false);
        layer.addEventListener("mouseout", function(e){ var those = this; mouseout(e,those) }, false);
        layer.addEventListener("click", function(e){ var those = this; filterCountry(e,those,name) }, false);

    });

    legenda (name)
    bestCountry (name)
    setColorOfVariablesButton (name)
    metroMode ()
    displayCurrentType (name)
}




function bestCountry (name) {
    // Show in the div the best country

    if (variablesIsHighToLow[name]) {
        // max is best
        document.querySelector("#sidebar #content").innerHTML = "<h2>" + countrynames[ranges[name].maxname] + "</h2>" + "<div class='image' style='background-image:url(images/" + ranges[name].maxname + ".jpg)'></div> " +  "ranges == " + ranges[name].max + "De Gini-coëfficiënt is berekend als een ratio van gebieden in de Lorenz-curve-grafiek. De Lorenz-curve tekent de proportie van het totale inkomen van een populatie (y-as) ten opzichte van de cumulatieve inkomsten van de onderste x% van de bevolking.";
    }
    else {
        // min is best
        document.querySelector("#sidebar #content").innerHTML = "<h2>" + countrynames[ranges[name].minname] + "</h2>" + "<div class='image' style='background-image:url(images/" + ranges[name].minname + ".jpg)'></div> " +  "ranges == " + ranges[name].min + "De Gini-coëfficiënt is berekend als een ratio van gebieden in de Lorenz-curve-grafiek. De Lorenz-curve tekent de proportie van het totale inkomen van een populatie (y-as) ten opzichte van de cumulatieve inkomsten van de onderste x% van de bevolking.";

    }



}



/// Metro === the menu behind the hamburger

var isMetroOn = true;

function metroMode () {
    if (isMetroOn == true) {
        $( "#variablesButton").css("width", "100vw" );
        $( "#variablesButton").css("height", "100vh" );


        $( "#variablesButton .content").css("margin-left", "auto" )
        $( "#variablesButton .content").css("margin-right", "auto" )
        $( "#variablesButton .content").css("max-width", "960px" )


        isMetroOn = false;
    }
    else {

        $( "#variablesButton .head").css("display", "none" );
        $( "#variablesButton .content").css("width", "inherit" )

        $( "#variablesButton").css("width", "27vw" );
        $( "#variablesButton").css("height", "48px" );
        $( "#variablesButton .content img").css("height", "37px" );
        $( "#variablesButton .content img").css("width", "37px" );
        $( "#variablesButton .content span").css("display", "none" );

        // dont enable metro again
    }


}

// Display the current type (for example gino)
function displayCurrentType (name) {

    var name_pos = variables.indexOf(name); 
    document.querySelector("#header").innerHTML = "<h1>" + variablesUI[name_pos] + "</h1>" + "<br />" + variablesExplain[name];

}


// In the MEtro interface
function setColorOfVariablesButton (name) {

    // $( "#variablesButton .content" ).each(function() {
    //     $( this ).css( "backgroundColor", "white" );
    // });


    $('#variablesButton .content').children('li').each(function () {
        $( this ).css( "backgroundColor", "white" );
        // alert(this.value); // "this" is the current element in the loop
    });

    $( "#variablesButton .content " + " ." + name).css("backgroundColor", "#5189B2" );


}

// Caled by the eventlistener mouseout
function resetHighlight(e,those) {

        var layer = e.target;

        layer.setStyle({
            weight: 0.5,
            color: '#666',
            dashArray: '',
            fillOpacity: 0.7
        });

}


function filterCountryInfo (e,those,name) {

    var value = e.target.feature.properties[name];
    value = Math.round(value);

    if (e.target.feature.properties[name] == NaNescaper) {
        value = "geen data"
    };

    // document.querySelector("#sidebar #content").innerHTML = e.target.feature.properties["nl_name"] + " " + value ;

    var countryname = e.target.feature.properties["name"];

    document.querySelector("#sidebar #content").innerHTML = "<h2>" + countrynames[countryname] + "</h2>" + "<div class='image' style='background-image:url(images/" + countryname + ".jpg)'></div> " +  "score == " + value + "<br /> Een kort verhaaltje over het land waar het nu over gaat, dit land doet het dus bijvoorbeeld bijzonder goed of slecht, geen idee anyway";

}


// // Showing the legenda in a div
// function hoverLegenda (e,those,name) {

//     var layer = e.target;

//     layer.setStyle({
//         weight: 5,
//         color: '#FF6000',
//         dashArray: '',
//         fillOpacity: 0.7
//     });

//     // // Only this type (for example gino)
//     // var value = e.target.feature.properties[name];
//     // value = Math.round(value);

//     // if (e.target.feature.properties[name] == NaNescaper) {
//     //     value = "geen data"
//     // };

//     // document.querySelector("#legenda .hovercontent").innerHTML = e.target.feature.properties["nl_name"] + " " + value ;


//     // All types (for example gino)
//     document.querySelector("#legenda .hovercontent").innerHTML = countrynames[e.target.feature.properties["name"]] + "<br />";

//     for (var i = 0; i < variables.length; i++) {
//         // console.log(variables[i]);

//         var value = e.target.feature.properties[variables[i]];
//         value = Math.floor(value);
//         document.querySelector("#legenda .hovercontent").innerHTML += value + variablesScale[variables[i]] + "<br />";

//     };

// }



function filterCountry(e,those,name) {

    filterCountryInfo(e,those,name)


    var thisCountryScore = e.target.feature.properties[name];

    // Create an array of all scores of this type
    var scoreList = [];
    euLayer.eachLayer(function(layer) {
        scoreList.push(layer.feature.properties[name]);
    });


    // Call for this scale in ranges
    var scale = ranges[name];

    // Yeah here we go again http://eelslap.com/
    function map(value, low1, high1, low2, high2) {
        return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
    }

    // Loop though all layers in the leaflet map
    // filter for countries who are better, the same or worse
    euLayer.eachLayer(function(layer) {

        if (layer.feature.properties[name] < thisCountryScore) {
            // Countries who perform better! :D :D :D

            // And again the higer is better            
            if (variablesIsHighToLow[name]) {
                // console.log("High")
                var outMin = badHues.length;
                var outMax = 0;

                var division = Math.floor(
                    map( layer.feature.properties[name],  scale.max+1,  scale.min-1,  outMax, outMin  )
                    );

                var color = badHues[division]

           }

            // Lower is better            
            else {
                var outMin = 0;
                var outMax = goodHues.length;

                var division = Math.floor(
                    map( layer.feature.properties[name],  scale.max+1,  scale.min-1,  outMax, outMin  )
                    );

                var color = goodHues[division]
            }


        }
        // Countries have the same value
        else if  (layer.feature.properties[name] === thisCountryScore) {
            // Some green
            var color = "#8AB2A7";

            // The selected country
            if (layer.feature.properties["name"] === e.target.feature.properties["name"]) {
                 var color = "#5189B2"; // blue
            };
        }
        // Countries who are worse :( :( :( :( :(
        else {

            // And again the higer is better            
            
            if (variablesIsHighToLow[name]) {
                // console.log("High")

                var outMin = goodHues.length;
                var outMax = 0

                var division = Math.floor(
                    map( layer.feature.properties[name],  scale.max+1,  scale.min-1,  outMax, outMin  )
                    );

                var color = goodHues[division]
            }
            // Lower is better            
            else {
                var outMin = goodHues.length;
                var outMax = 0;

                var division = Math.floor(
                    map( layer.feature.properties[name],  scale.min-1,  scale.max+1,  outMin, outMax  )
                    );

                var color = badHues[division]

            }
                


        }

        // And finaly arange all the colours from all countries
        layer.setStyle({
            fillColor: color,
            fillOpacity: 0.8,
            color: '#666',
            weight: 0.5
        });

    });
}



// The popup feature

var timer;

function mousemove(e,those,name) {
    // https://www.mapbox.com/mapbox.js/example/v1.0.0/choropleth/

    var layer = e.target;



    layer.setStyle({
        weight: 5,
        color: '#FF6000',
        dashArray: '',
        fillOpacity: 0.7
    });




    var newpos = {
        lat: (e.latlng.lat+1),        
        lng: (e.latlng.lng),        
    }

    popup.setLatLng(newpos);


    var content = e.target.feature.properties[name];
    content = Math.round(content);


    if (e.target.feature.properties[name] == NaNescaper) {
        content = "geen data"
    };

     content = countrynames[e.target.feature.properties["name"]] + " <br />" + content + " " + variablesScale[name]


    // var content = countrynames[e.target.feature.properties["name"]] + "<br />";

    // for (var i = 0; i < variables.length; i++) {
    //     // console.log(variables[i]);

    //     var value = e.target.feature.properties[variables[i]];
    //     value = Math.floor(value);
    //     content += value + variablesScale[variables[i]] + "<br />";

    // };

    timer = window.setTimeout(function() {
        popup.setContent(content);

        if (!popup._map) popup.openOn(map);

    }, 200);
}


function mouseout(e) {
    var layer = e.target;

    layer.setStyle({
        fillOpacity: 0.8,
        color: '#666',
        weight: 0.5
    });
}


</script>


</body>
</html>

